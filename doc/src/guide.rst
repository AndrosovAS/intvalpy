Реализация класса Interval
===============

В данном разделе представлен обзор использования класса Interval.

Выполните инструкцию:

    >>> from intvalpy import Interval, precision

С помощью неё подключается интервальный класс `Interval` из реализованной библиотеки `intvalpy`, которая была предварительно
установлена с помощью команды `pip install intvalpy`.

.. Содержание::

Cоздание
------------
Класс `Interval` был создан в соответствии со стандартом IEEE 754-2008, где округление происходит к ближайшему чётному числу.
Это позволяет в значительной степени ускорить вычислительные верхнеуровневые функции и сократить время вычислений.
Однако в задачах, где требуется повышенная точность, Вы можете перейти от стандартного представления числа в виде `double float` к типу `mpf`.
Для этого выполните следующую команду:

    >>> precision.extendedPrecisionQ = True

Также Вы можете задать рабочую точность (после какого знака после запятой будет происходить округление):

    >>> precision.dps(50)

По умолчанию точность выставлена до 36-го знака после запятой.

Одиночный интервал
~~~~~~~~~~~~~~~~~~

Для создания объекта представляющего собой математический промежуток, который содержит все значения между 1 и 2,
необходимо написать следующее:

    >>> data = Interval(1, 2)
    >>> print(data)

После запуска кода, в окне вывода появится результат [1, 2]. Для проверки типа созданного объекта можно воспользоваться
командой `type(data)` которая выдаст ``intvalpy.RealInterval.ClassicalArithmetic``.

Массив из интервалов
~~~~~~~~~~~~~~~~~~

В случае, когда пользователь хочет создать массив интервалов, то ему следует указать массивы правых и левых концов.
Например:

    >>> a = [2, 7, -3]
    >>> b = [4, 5, 1]
    >>> data = Interval(a, b)
    # Interval(['[2, 4]', '[5, 7]', '[-3, 1]'])

Можно увидеть, что второй интервал не таков, каким он был введён пользователем (левый конец больше правого),
а значит вводится неправильный интревал. Программа автоматически конвертировала его в <<правильный>>.

В рамках модуля `intvalpy` она может как применяться, так и отключаться с переходом в польную интервальную арифметику.

    >>> data = Interval(a, b, sortQ=False)
    # Interval(['[2, 4]', '[7, 5]', '[-3, 1]'])
    >>> print(type(data))
    # <class 'intvalpy.RealInterval.KauherArithmetic'>

Пустой интервал
~~~~~~~~~~~~~~~~~~

Наконец рассмотрим реализацию пустого интервала, который реализуется обычно как [NaN, NaN]. Это позволяет
использовать для реализации проверки пустоты/непустоты интервалов стандартные функции распознавания NaN
из популярных языков программирования.

Итак, пустой интервал создаётся таким образом:

    >>> data = Interval(None, None)
    # Interval(['[nan, nan]'])

Альтернативные способы создания
~~~~~~~~~~~~~~~~~~

Реализованный класс также поддерживает другие способы задания интервальных данных. Например, через середину и радиус интервала:

>>> mid = [3, 6, -2]
>>> rad = [0.2, 1, 5]
>>> Interval(mid, rad, midRadQ=True)
# Interval(['[2.8, 3.2]', '[5, 7]', '[-7, 3]'])

Или же последовательная пара чисел, которая общепринята для написания интервала на бумаге:

>>> data = [
>>>     [[2, 4], [-2, 1]],
>>>     [[-1, 2], [2, 4]]
>>> ]
>>> Interval(data)
# Interval([['[2, 4]', '[-2, 1]'],
            ['[-1, 2]', '[2, 4]']])

Операции между интервалами
----------


Арифметические операции
~~~~~~~~~~~~~~~~~~

Все арифметические операции между интервалами происходят в соответсвии с конструктивными определениями,
которые Вы можете найти в `монографии <http://www.nsc.ru/interval/Library/InteBooks/SharyBook.pdf>`_ Шарого С.П.

Для большей ясности рассмотрим на конкретных примерах.

Итак, первый пример рассмотрим, как сложение двух массивов состоящих из интеровалов:

    >>> f = Interval([-8, -6, -4], [3, -2, -1])
    >>> s = Interval([-8, -8, 4], [-1, -3, 4])
    >>> f + s
    interval(['[-16.0, 2.0]', '[-14.0, -5.0]', '[0.0, 3.0]'])

Другие два примера показывают, что можно проводить такие поэлементные операции даже когда один из элементов
является простым типом или списком:

    >>> s = 2
    >>> s + f
    # interval(['[-6.0, 5.0]', '[-4.0, 0.0]', '[-2.0, 1.0]'])
    >>> s = [3, 5, -2]
    >>> s + f
    # interval(['[-5.0, 6.0]', '[-1.0, 3.0]', '[-6.0, -3.0]'])

Также подобные действия можно производить и с остальными арифметическими операциями. Единственным исключением является
деление на нуль содержащие интервалы. Подобную функциональность данный класс не поддерживает.

В случае, когда один из интервалов является <<правильным>>, а другой нет, тогда результирующий ответ автоматически
переходит в полную интервальную арифметику:

    >>> f = Interval(2, 3)
    >>> s = Interval(2, -3, sortQ=False)
    >>> difference = f - s
    # Interval(['[5, 1]'])
    >>> type(difference)
    # <class 'intvalpy.RealInterval.KauherArithmetic'>


Другие операции
~~~~~~~~~~~~~~~~~~

Для взятия модуля интервала или возведения в степень с натуральным показателем можно воспользоваться
стандартным и привычным синтаксисом:

    >>> abs(Interval(-2, 3))
    # Interval(['[0, 3]'])
    >>> Interval(-2, 3) ** 2
    # Interval(['[0, 9]'])

Финальным аккордом данного параграфа станет демонстрация реализованного матричного и скалярного произведений:

    >>> inf1 = [[-1., -2.],[-7., -5.]]
    >>> sup1 = [[ 3., 5.],[-4., 7.]]
    >>> f = Interval(inf1, sup1)
    >>> inf2 = [[-3., 4.],[-7., -8.]]
    >>> sup2 = [[-2., 4.],[ 3., 0.]]
    >>> s = Interval(inf2, sup2)
    >>> f @ s
    # Interval([['[-44.0, 18.0]', '[-44.0, 28.0]']
                ['[-41.0, 56.0]', '[-84.0, 24.0]']])

Для вызова разных произведений не нужно прописывать отдельные строчки кода. Достаточно просто поменять глубину
одного из массивов. Допустим, если f интервальная матрица, а s интервальный вектор, то всё также будет работать.


Методы класса Interval
----------

При работе с интервальными величинами зачастую полезно, а порой и необходимо отдельно рассматривать некоторые атрибуты.
К примеру, пользователю может понадобиться вывести только левые или правые концы интервалов, или же вычислить
середину интервала. Все эти операции, а также некоторые другие, которые описаны ниже, достаточно часто встречаются
по ходу работы. Поэтому целесообразно включить в данный класс уже реализованные функции для описанных действий.


Концы интервала
~~~~~~~~~~~~~~~~~~

Итак, для начала рассмотрим самые тривильные методы для вывода концов интервала:

    >>> f = Interval([-8., -1., 1.], [-1., 0., 4.])
    interval([’[-8.0, -1.0]’, ’[-1.0, 0.0]’, ’[1.0, 4.0]’])
    >>> f.a
    # array([-8., -1., 1.])
    >>> f.b
    # array([-1., 0., 4.])

Отметим, что выводимый результат является типом ```ndarray``, поскольку концы внутри класса содержаться именно таким образом.

Абсолютные характеристики интервалов
~~~~~~~~~~~~~~~~~~

Для получения радиуса, ширины, середины или мигнитуды интервалов необходимо вызвать метода, названия которых
совпадают с общепринятыми обозначениями:

    >>> f = Interval([-8., -1., 1.], [-1., 0., 4.])
    >>> f.rad
    # array([3.5, 0.5, 1.5])
    >>> f.wid
    # array([7., 1., 3.])
    >>> f.mid
    # array([-4.5, -0.5, 2.5])
    >>> f.mig
    # array([1., 0., 1.])

Копирование интервальных массивов
~~~~~~~~~~~~~~~~~~

Для простейшего копирования элементов, т.е. получения объекта равному исходному, за исключением индетификатора,
можно воспользоваться срезом изначального изменяемого объекта, например:

    >>> f = Interval([1, 2], [3, 4])
    >>> s = f[:]
    >>> s
    # interval([’[1, 3]’, ’[2, 4]’])
    >>> s == f
    # [True True]
    >>> s is f
    # False

Однако при таком подходе будет получена поверхностная копия (т.е. копируются самые общие значения, которые заполняются
точно такими же ссылками на элементы, что находятся в корневом объекте). При неизменяемости элементов это не вызывает
никаких проблем и экономит память, но созданный класс изменяем, а потому необходимо глубокая копия.

Для этого был реализован метод `copy`:

    >>> s = f.copy
    >>> print(s == f)
    # [True True]
    >>> s[0] += 1000
    >>> print(s == f)
    # [False True]

Другие методы
~~~~~~~~~~~~~~~~~~

Последними реализованными методами данного класса являются алгебраически обратные и противоположные интервалы:

    >>> f = Interval([-8., -1., 1.], [-1., 0., 4.])
    >>> f.invbar
    # interval([’[-1.0, -8.0]’, ’[0.0, -1.0]’, ’[4.0, 1.0]’])
    >>> f.opp
    # interval([’[8.0, 1.0]’, ’[1.0, 0.0]’, ’[-1.0, -4.0]’])

Применение этих методов приводит к необратимому переходу к полной интервальной арифметики Каухера.


Эмуляция коллекций
----------

Принадлежность интервалу
~~~~~~~~~~~~~~~~~~

Во время работы и реализации интервальных алгоритмов порой крайне необходимо обладать информацией,
принадлежит ли точка или интервал другому интервалу. Для этого был переопределён оператор ``in``
которй предназначен именно для этих целей:

    >>> f = Interval(-5, 8)
    >>> -4 in f
    True
    >>> f = Interval(-5, 8)
    >>> Interval(-2, 1) in f
    True
    >>> Interval(-5.2, 1) in f
    False


Длина коллекции, срезы и удаление элементов
~~~~~~~~~~~~~~~~~~

Как уже упоминалось ранее, одной из главных особенностей реализованного класса является возможность
работать с векторами и матрицами. Это автоматически порождает необходимость вычисления длины массива,
а также возможность работы с коллекциями.

    >>> f = Interval([-8., -1., 1.], [-1., 0., 4.])
    >>> len(f)
    # 3

Для получения N-го значения или нескольких значений (в будущем будем называть это срезом массива)
можно воспользоваться вполне привычными инструментами. Более того, поскольку класс `Interval` изменяемый,
то существует возможность также изменять или удалять элементы:

    >>> f[1]
    # [-1.0, 0.0]
    >>> f[1:]
    # interval([’[-1.0, 0.0]’, ’[1.0, 4.0]’])
    >>> f[1:] = Interval([-5,-10], [5, 10])
    >>> f
    # interval([’[-8.0, -1.0]’, ’[-5.0, 5.0]’, ’[-10.0, 10.0]’])
    >>> del f[1]
    >>> f
    # interval([’[-8.0, -1.0]’, ’[-10.0, 10.0]’])

Для изменения порядка элементов на противоположный следует воспользоваться следующей инструкцией:

    >>> f = Interval([-8., -1., 1.], [-1., 0., 4.])
    >>> f[::-1]
    # interval(['[1.0, 4.0]', '[-1.0, 0.0]', '[-8.0, -1.0]'])


Согласование с другими библиотеками на Python
----------

В случае, если пользователь захочет выйти за пределы данного модуля, например, создать массив с помощью
библиотеки `numpy` и сложить с интервальным вектором, или преобразовать в массив типа ``ndarray``, то для этого
специально прописано согласование данного класса с другими библиотеками:

    >>> import numpy as np
    >>> f = Interval([-8., -1., 1.], [-1., 0., 4.])
    >>> s = np.array(f)
    >>> s
    # array([[-8.0, -1.0], [-1.0, 0.0], [1.0, 4.0]], dtype=object)

Также с помощью библиотеки `numpy` возможно вычислить такие функции, как ``sin``, ``cos`` и ``exp``:

    >>> np.sin(f)
    # interval([’[-1.0, 1.0]’, ’[-0.841471, 0.0]’, ’[-0.756802, 1.0]’])
    >>> np.cos(f)
    # interval([’[-1.0, 1.0]’, ’[0.540302, 1.0]’, ’[-1.0, 0.540302]’])
    >>> np.exp(f)
    # interval([’[0.000335, 0.367879]’, ’[0.367879, 1.0]’, ’[2.718282, 54.598150]’])

Для всех перечисленных выше функций область значений на любом вещественном интервале может быть несложно найдена
на основе информации об их монотонности на тех или иных участках области определения. Поэтому их оптимальные
интервальные расширения строятся без проблем.
