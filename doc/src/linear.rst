Линейные системы
===============

В данном разделе представлен обзор функций для линейных систем.

.. Содержание::

Вариабельность системы
------------

При решении системы мы обычно получаем множество различных оценок, одинаково пригодных в качестве ответов к задаче
и согласующихся с её данными. Именно вариабельность характеризует то насколько мало или велико это множество.

Для получения количественной меры воспользуйтесь функцией ``ive``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            N: int
                Количество угловых матриц для которых вычисляется обусловленность.

Returns:
            out: float
                Возвращается мера вариабельности IVE.

Пример:

>>> import intvalpy as ip
>>>
>>> inf = [[98, 99],
>>>        [97, 98],
>>>        [96, 97]]
>>>
>>> sup = [[100, 101],
>>>        [99, 100],
>>>        [98, 99]]
>>>
>>> A = ip.Interval(inf, sup)
>>> b = ip.Interval([190, 200, 190], [210, 220, 210])
>>>
>>> ip.linear.ive(A, b)
1.56304

Для ускорения расчётов был использован рандомизированный алгоритм.

Более подробную информацию Вы можете узнать из `статьи <http://www.nsc.ru/interval/shary/Papers/SShary-VariabMeasure-JCT.pdf>`_ Шарого С.П.


Распознающий функционал Uni
------------

Перед тем, как решать систему уравнений, мы хотим знать, существует ли решение. Для случая слабой согласованности был реализован
распознающий функционал ``Uni``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            x: float, array_like
                Точка в которой вычисляется распознающий функционал.
                По умолчанию x равен массиву из нулей.

            maxQ: bool
                Если значение параметра равно True, то производится
                максимизация функционала.

            x0: float, array_like
                Первоначальная догадка.

            tol: float
                Погрешность для прекращения оптимизационного процесса.

            maxiter: int
                Максимальное количество итераций.

Returns:
            out: float, tuple
                Возвращается значение распознающего функционала в точке x.
                В случае, если maxQ=True, то возвращается кортеж, где
                первый элемент -- корректность завершения оптимизации,
                второй элемент -- точка оптимума,
                третий элемент -- значение функции в этой точке.

Примеры:

Для получения значения функции в конкретной точке

>>> import intvalpy as ip
>>> import numpy as np
>>>
>>> A = ip.Interval([[2, -2],[-1, 2]], [[4,1],[2,4]])
>>> b = ip.Interval([-2, -2], [2, 2])
>>>
>>> x = np.array([1,2])
>>> ip.linear.Uni(A, b, x)
-1.0

Если же Вы хотите узнать в какой точке достигается максимальное значение функции

>>> ip.linear.Uni(A, b, maxQ=True)
(True, array([3.18057462e-13, 1.37470524e-13]), 1.9999999999996387)


Распознающий функционал Tol
------------

Перед тем, как решать систему уравнений, мы хотим знать, существует ли решение. Для случая сильной согласованности был реализован
распознающий функционал ``Tol``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            x: float, array_like
                Точка в которой вычисляется распознающий функционал.
                По умолчанию x равен массиву из нулей.

            maxQ: bool
                Если значение параметра равно True, то производится
                максимизация функционала.

            x0: float, array_like
                Первоначальная догадка.

            tol: float
                Погрешность для прекращения оптимизационного процесса.

            maxiter: int
                Максимальное количество итераций.

Returns:
            out: float, tuple
                Возвращается значение распознающего функционала в точке x.
                В случае, если maxQ=True, то возвращается кортеж, где
                первый элемент -- корректность завершения оптимизации,
                второй элемент -- точка оптимума,
                третий элемент -- значение функции в этой точке.

Примеры:

Для получения значения функции в конкретной точке

>>> import intvalpy as ip
>>> import numpy as np
>>>
>>> A = ip.Interval([[2, -2],[-1, 2]], [[4,1],[2,4]])
>>> b = ip.Interval([-2, -2], [2, 2])
>>>
>>> x = np.array([1,2])
>>> ip.linear.Tol(A, b, x)
-8.0

Если же Вы хотите узнать в какой точке достигается максимальное значение функции

>>> ip.linear.Tol(A, b, maxQ=True)
(True, array([-2.61487556e-13,  1.67516879e-13]), 1.999999999998619)


Визуализация системы неравенств
------------

В случае, если система уравнений является точечной, то следует воспользоваться функцией ``lineqs``. Функция визуализирует
множество решений системы линейных алгебраических неравенств A x >= b с двумя переменными методом граничных интервалов,
а также выводит вершины множества решений.

Parameters:
            A: float
                Матрица системы линейных алгебраических неравенств.

            b: float
                Вектор правой части системы линейных алгебраических неравенств.

Optional Parameters:
            show: bool
                Визуализация множества решений.

            title: str
                Верхняя легенда графика.

            color: str
                Каким цветом осуществляется отрисовка графика.

            bounds: array_like
                Границы отрисовочного окна.

            alpha: float
                Прозрачность графика.

            s: float
                Насколько велики точки вершин.

            size: tuple
                Размер отрисовочного окна.

            save: bool
                Если значение True, то график сохраняется.

Returns:
            out: list
                Возвращается список упорядоченных вершин.
                В случае, если show = True, то график отрисовывается.

Пример:

Для примера можно рассмотреть систему описывающую двенадцатиугольник:

>>> import numpy as np
>>> import intvalpy as ip
>>>
>>> A = -np.array([[-3, -1],
>>>               [-2, -2],
>>>               [-1, -3],
>>>               [1, -3],
>>>               [2, -2],
>>>               [3, -1],
>>>               [3, 1],
>>>               [2, 2],
>>>               [1, 3],
>>>               [-1, 3],
>>>               [-2, 2],
>>>               [-3, 1]])
>>> b = -np.array([18,16,18,18,16,18,18,16,18,18,16,18])
>>>
>>> vertices = ip.linear.lineqs(A, b, color='blue', alpha=0.2, size=(10,12))


Визуализация множества решений ИСЛАУ
------------

В случае, когда система является интервальной то для визуализации множества решений линейных алгебраических уравнений
A x = b с двумя переменными методом граничных интервалов необходимо воспользоваться функцией ``IntLinIncR2``, которая
также выводит вершины множества решений.

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            show: bool
                Визуализация множества решений.

            title: str
                Верхняя легенда графика.

            consistency: str
                Параметр указывает какое множество решений (объединённое или
                допусковое) будет выведено в ответе.

            bounds: array_like
                Границы отрисовочного окна.

            color: str
                Каким цветом осуществляется отрисовка графика.

            alpha: float
                Прозрачность графика.

            s: float
                Насколько велики точки вершин.

            size: tuple
                Размер отрисовочного окна.

            save: bool
                Если значение True, то график сохраняется.

Returns:
            out: list
                Возвращается список упорядоченных вершин в каждом ортанте
                начиная с первого и совершая обход в положительном направлении.
                В случае, если show = True, то график отрисовывается.

Пример:

>>> import numpy as np
>>> import intvalpy as ip
>>>
>>> A = ip.Interval([[-1, -1],[-1, -1]], [[1,1], [-1,1]])
>>> b = ip.Interval([1,-2], [1,2])
>>>
>>> vertices = ip.linear.IntLinIncR2(A, b, title='Infinite solution', size=(10,12))


Метод Гаусса
------------

Метод Гаусса для решения ИСЛАУ можно вызвать с помощью функции ``Gauss``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Returns:
            out: Interval
                Возвращается интервальный вектор решений.

Пример:

>>> import intvalpy as ip
>>>
>>> A = ip.Interval([[2, -2],[-1, 2]], [[4, 1],[2, 4]])
>>> b = ip.Interval([-2, -2], [2, 2])
>>>
>>> ip.linear.Gauss(A, b)
interval(['[-5.0, 5.0]', '[-4.0, 4.0]'])


Метод Гаусса-Зейделя
------------

Итерационный метод Гаусса-Зейделя для решения ИСЛАУ можно вызвать с помощью функции ``Gauss_Seidel``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            x0: Interval
                Начальный брус, в котором ищется решение.

            P: Interval
                Матрица предобуславливания.
                В случае, если параметр не задан, то берётся обратное среднее.

            tol: float
                Погрешность для остановки итерационного процесса.

            maxiter: int
                Максимальное количество итераций.

Returns:
            out: Interval
                Возвращается интервальный вектор решений.

Пример:

>>> import intvalpy as ip
>>>
>>> A = ip.Interval([[0.5, -0.456], [-0.438, 0.624]],
>>>                  [[1.176, 0.448], [0.596, 1.36]])
>>> b = ip.Interval([0.316, 0.27], [0.632, 0.624])
>>>
>>> ip.linear.Gauss_Seidel(A, b, P=False)
interval(['[-4.266757, 6.076814]', '[-5.371444, 5.265456]'])


Метод Рона для переопределённых систем
------------

Метод Дж. Рона для переопределённых ИСЛАУ:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            tol: float
                Погрешность для остановки итерационного процесса.

            maxiter: int
                Максимальное количество итераций.

Returns:
            out: Interval
                Возвращается интервальный вектор решений.

Пример:

>>> import numpy as np
>>> import intvalpy as ip
>>>
>>> t = np.array([31, 69, 144, 198, 359, 446, 536, 626, 716, 809, 903, 1039, 1161, \
>>>               1316, 1536, 2029, 2400, 29, 64, 135, 189, 261, 342, 432, 517, 613, \
>>>               699, 792, 888, 1020, 1142, 1301, 1511, 2017, 2400, 65, 96, 521, 617, \
>>>               705, 794, 892, 1024, 1148, 1309, 1520, 2003, 2400, 27, 83, 121, 173, \
>>>               234, 307, 394, 467, 553, 636, 715, 806, 915, 1026, 1170, 1364, 1500, \
>>>               2400, 77, 112, 155, 216, 367, 458, 541, 639, 741, 825, 936, 1061, \
>>>               1189, 1200, 1426, 1902, 2400, 67, 102, 145, 206, 357, 448, 531, 629, \
>>>               731, 815, 900, 1030, 1115, 1326, 1554, 2015, 2400]);
>>> data = np.array([0.8, 0.84, 0.85, 0.89, 0.93, 0.93, 0.93, 0.93, 0.93, 0.93, 0.93, \
>>>                  0.95, 0.95, 0.96, 0.97, 0.99, 1, 0.79, 0.82, 0.85, 0.89, 0.91, 0.92, \
>>>                  0.93, 0.93, 0.94, 0.93, 0.93, 0.94, 0.95, 0.95, 0.96, 0.97, 0.99, 1, \
>>>                  0.84, 0.84, 0.94, 0.94, 0.94, 0.95, 0.95, 0.96, 0.96, 0.97, 0.96, \
>>>                  0.97, 1, 0.78, 0.81, 0.84, 0.89, 0.9, 0.92, 0.93, 0.92, 0.93, 0.93, \
>>>                  0.92, 0.93, 0.95, 0.95, 0.96, 0.97, 0.98, 1, 0.8, 0.82, 0.86, 0.9, \
>>>                  0.91, 0.93, 0.93, 0.94, 0.94, 0.93, 0.94, 0.95, 0.95, 0.96, 0.96, \
>>>                  0.98, 1, 0.81, 0.83, 0.86, 0.9, 0.91, 0.93, 0.93, 0.94, 0.94, 0.93, \
>>>                  0.93, 0.94, 0.94, 0.97, 0.96, 0.98, 1])
>>>
>>> t = t + ip.Interval(0, 0)
>>> data = data + ip.Interval(-0.0255, 0.0255)
>>>
>>> A = ip.zeros((100, 2))
>>> A[:, 0] += ip.Interval(1, 1)
>>> A[:, 1] -= data
>>> b = t * (data - 1)
>>>
>>> ip.linear.Rohn(A, b)
interval(['[-396.621157, 575.293503]', '[-418.434473, 687.961243]'])


Более подробную информацию Вы можете узнать из `статьи <https://www.researchgate.net/publication/220252801_Enclosing_solutions_of_overdetermined_systems_of_linear_interval_equations>`_ Дж. Рона.


Метод дробления решений
------------

Гибридный метод дробления решений PSS, подробно описанный в `монографии <http://www.nsc.ru/interval/Library/InteBooks/SharyBook.pdf>`_. PSS-алгортимы предназначены для нахождения внешних оптимальных оценок множеств решений интервальных систем линейных алгебраических уравнений (ИСЛАУ) **A** x = **b**. 

В качестве базового метода внешнего оценивания в программе используется интервальный метод Гаусса (функция Gauss), если система является квадратной. В случае, если система переопределённая, то применяется простейший алгоритм, предложенный Дж. Роном (функция Rohn). Поскольку задача NP-трудная, то остановка процесса может произойти по количеству пройденных итераций. PSS-методы являются последовательно гарантирующими, т.е. при обрыве процесса на любом количестве итераций приближённая оценка решения удовлетворяет требуемому способу оценивания. 

Возвращает формальное решение интервальной системы линейных уравнений. В случае, если оценивать все компоненты нет необходимости, то можно оценить одну любую nu-ю компоненту. 


Parameters
-------
-------
A : Interval
            Входная интервальная матрица ИСЛАУ, которая может быть как квадратной, так и прямоугольной.

b : Interval
            Интервальной вектор правой части ИСЛАУ.

tol : float, optional
            Погрешность, определающая, когда дальнейшее дробление брусов излишне, т.е. их ширина "достаточно близка" к нулю, что может считаться точно нулевой. 

maxiter : int, optional 
            Максимальное количество итераций для выполнения алгоритма. 

nu : int, optional
            Выбор номера компоненты, вдоль которой оценивается множество решений. 


Returns
-------
-------
out : Interval
    Интервальный вектор, который после подстановки в систему уравнений и выполнения всех операций по правилам арифметики и анализа обращает уравнения в инстинные равенства. 


Examples
-------
-------
>>> A, b = ip.Shary(4)
>>> ip.linear.PSS(A, b)
interval(['[-4.347826, 4.347826]', '[-4.347826, 4.347826]', '[-4.347826, 4.347826]', '[-4.347826, 4.347826]'])

Возврат интервального вектора решения NP-трудной системы.

>>> A, b = ip.Neumeier(3, 3.33)
>>> ip.linear.PSS(A, b, nu=0, maxiter=5000)
interval(['[-2.373013, 2.373013]'])

Возвращена отдельная компонента. В связи с тем, что в системе Ноймаера параметр theta=3.33 является жёстким условием, необходимо увеличить количество итераций для получения оптимальной оценки.
