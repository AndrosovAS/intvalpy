Линейные системы
===============

В данном параграфе представлен обзор функций для исследования разрешимости и получения оценки
множества решений интервальных линейных систем.

Выполните инструкцию для подключения необходимых модулей:

    >>> import intvalpy as ip
    >>> import numpy as np

.. Содержание::

Вариабельность системы
------------

При решении системы мы обычно получаем множество различных оценок, одинаково пригодных в качестве ответов к задаче
и согласующихся с её данными. Именно вариабельность характеризует то насколько мало или велико это множество.

Для получения количественной меры воспользуйтесь функцией ``ive``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            N: int
                Количество угловых матриц для которых вычисляется обусловленность.

Returns:
            out: float
                Возвращается мера вариабельности IVE.

Пример:

>>> import intvalpy as ip
>>>
>>> inf = [[98, 99],
>>>        [97, 98],
>>>        [96, 97]]
>>>
>>> sup = [[100, 101],
>>>        [99, 100],
>>>        [98, 99]]
>>>
>>> A = ip.Interval(inf, sup)
>>> b = ip.Interval([190, 200, 190], [210, 220, 210])
>>>
>>> ip.linear.ive(A, b)
1.56304

Для ускорения расчётов был использован рандомизированный алгоритм.

Более подробную информацию Вы можете узнать из `статьи <http://www.nsc.ru/interval/shary/Papers/SShary-VariabMeasure-JCT.pdf>`_ Шарого С.П.


Распознающие функционалы
------------

Перед тем, как приступить к решению системы уравнений с интервальными данными необходимо понять, а разрешима ли она.
Для этого рассматривается задача о распознавании разрешимости, т.е. непустоты множества решений.
В случае интервальной линейной (m x n)-системы уравнений потребуется решить не более чем 2\ :sup:`n`
линейных неравенств размера 2m+n. Это следует из факта о выпуклости и многогранности пересечения множеств решений
интервальной системы линейных алгебраических уравнений (ИСЛАУ) с каждым из ортантов пространства **R**\ :sup:`n`.
Уменьшение количества неравенств принципиально невозможно, что следует из факта труднорешаемости задачи,
т.е. её NP-трудности. Ясно, что выше описанный метод применим лишь при малой размерности задачи,
поэтому был предложен *метод распознающего функционала*.


Распознающий функционал Uni
~~~~~~~~~~~~~~~~~~

В случае, когда необходимо проверить интервальную систему линейных уравнений на её слабую разрешимость
следует воспользоваться функционалом ``Uni``. Для его оптимизации используется широко известный метод Нелдера-Мида,
который не использует градиенты, поскольку в функции присутствует взятие абсолютного значения.

Parameters:
""""""""""""""""""

A : Interval
            Входная интервальная матрица ИСЛАУ, которая может быть как квадратной, так и прямоугольной.

b : Interval
            Интервальной вектор правой части ИСЛАУ.

x : float, array_like, optional
            Точка в которой вычисляется распознающий функционал.
            По умолчанию x равен массиву из нулей.

maxQ : bool, optional
            Если значение параметра равно True, то производится максимизация функционала.

x0 : float, array_like, optional
            Первоначальная догадка для поиска глобального максимума.

tol : float, optional
            Погрешность для прекращения оптимизационного процесса.

maxiter : int, optional
            Максимальное количество итераций.


Returns:
""""""""""""""""""

out: float, tuple
            Возвращается значение распознающего функционала в точке x.
            В случае, если maxQ=True, то возвращается кортеж, где
            первый элемент -- корректность завершения оптимизации,
            второй элемент -- точка оптимума,
            третий элемент -- значение функции в этой точке.

Examples:
""""""""""""""""""

В качестве примера рассмотрим широко известную интервальную систему, предложенную Бартом-Нудингом:

>>> A = ip.Interval([[2, -2],[-1, 2]], [[4,1],[2,4]])
>>> b = ip.Interval([-2, -2], [2, 2])


Для получения значения функции в конкретной точке необходимо выполнить следующую инструкцию

>>> x = np.array([1,2])
>>> ip.linear.Uni(A, b, x)
-1.0

Таким образом видно, что точка не лежит в множестве решений системы, т.к. значение распознающего функционала отрицательно.
Для получения глобального максимума функции, чтобы понять разрешима или не разрешима система, следует указать истинность значения параметра `maxQ`:

>>> ip.linear.Uni(A, b, maxQ=True)
(True, array([0., 0.]), 2.0)

Поскольку интервальная система линейна, но матрица **А** не является точечной, то нет гарантий, что был достигнут глобальный максимум функции.
В качестве некоторого решения пользователь может указать первоначальную догадку, исходя, например, из особенностей матрицы.
Это также может ускорить процесс поиска глобального максимума.


Распознающий функционал Tol
~~~~~~~~~~~~~~~~~~

В случае, когда необходимо проверить интервальную систему линейных уравнений на её сильную разрешимость
следует воспользоваться функционалом ``Tol``. Для его оптимизации используется проверенная временем программа `tolsolvty`,
которая пригодна для решения практических задач.

Parameters:
""""""""""""""""""

A : Interval
            Входная интервальная матрица ИСЛАУ, которая может быть как квадратной, так и прямоугольной.

b : Interval
            Интервальной вектор правой части ИСЛАУ.

x : float, array_like, optional
            Точка в которой вычисляется распознающий функционал.
            По умолчанию x равен массиву из нулей.

maxQ : bool, optional
            Если значение параметра равно True, то производится максимизация функционала.

x0 : float, array_like, optional
            Первоначальная догадка для поиска глобального максимума.

tol : float, optional
            Погрешность для прекращения оптимизационного процесса.

maxiter : int, optional
            Максимальное количество итераций.


Returns:
""""""""""""""""""

out: float, tuple
            Возвращается значение распознающего функционала в точке x.
            В случае, если maxQ=True, то возвращается кортеж, где
            первый элемент -- корректность завершения оптимизации,
            второй элемент -- точка оптимума,
            третий элемент -- значение функции в этой точке.

Examples:
""""""""""""""""""

В качестве примера рассмотрим широко известную интервальную систему, предложенную Бартом-Нудингом:

>>> A = ip.Interval([[2, -2],[-1, 2]], [[4,1],[2,4]])
>>> b = ip.Interval([-2, -2], [2, 2])


Для получения значения функции в конкретной точке необходимо выполнить следующую инструкцию

>>> x = np.array([1,2])
>>> ip.linear.Tol(A, b, x)
-8.0

Таким образом видно, что точка не лежит в множестве решений системы, т.к. значение распознающего функционала отрицательно.
Для получения глобального максимума функции, чтобы понять разрешима или не разрешима система, следует указать истинность значения параметра `maxQ`:

>>> ip.linear.Tol(A, b, maxQ=True)
(True, array([0., 0.]), 2.0)

Отличительным свойством функционала `Tol` от функционалов `Uni` и `Uss` является то, что вне зависимости от того является ли матрица **A**
интервальной или точечной, функционал всегда имеет только один экстремум. Таким образом не важно с какой начальной догадки начинать поиск.
Однако, если указать начальную точку, то поиск глобального максимума может ускориться.


Список использованной литературы
~~~~~~~~~~~~~~~~~~

[1] С.П. Шарый - `Разрешимость интервальных линейных уравнений и анализ данных с неопределённостями <http://www.nsc.ru/interval/shary/Papers/SharyAiT.pdf>`_ // Автоматика и Телемеханика, No 2, 2012

[2] С.П. Шарый, И.А. Шарая - `Распознавание разрешимости интервальных уравнений и его приложения к анализу данных <http://www.nsc.ru/interval/shary/Papers/Sharys-JCT2013.pdf>`_ // Вычислительные технологии, Том 18, No 3, 2013, стр. 80-109.

[3] С.П. Шарый - `Сильная согласованность в задаче восстановления зависимостей при интервальной неопределённости данных <http://www.nsc.ru/interval/shary/Papers/SShary-JCT-2017.pdf>`_ // Вычислительные технологии, Том 22, No 2, 2017, стр. 150-172.


Метод граничных интервалов
------------

В случае, когда появляется необходимость визуализировать множество решений системы линейных неравенств (или интервальную систему уравнений),
а также получить все вершины множество, можно прибегнуть к методам решения проблемы перечисления вершин. Однако существующие реализации
имеют ряд недостатков: работа только с квадратными системами, плохая обработка неограниченных множеств.

Основываясь на применении *матрицы граничных интервалов* был предложен *метод граничных интервалов* для исследования и визуализации полиэдральных множеств.
Главными преимуществами данного подхода является возможность работать с неограниченными и тощими множествами решений, а также с линейными системами,
когда количество уравнений отлично от количества неизвестных.

Для общего понимания работы алгоритма укажем его основные шаги:
::
    1. Формирование матрицы граничных интервалов;
    2. Изменение матрицы граничных интервалов с учётом окна отрисовки;
    3. Построение упорядоченных вершин полиэдрального множества решений;
    4. Вывод построенных вершин и (если надо) отрисовка полиэдра.


Двумерная визуализация линейной системы неравенств
~~~~~~~~~~~~~~~~~~

Для работы с линейной системой алгебраических неравенств A x >= b, когда количество неизвестных равно двум, необходимо
воспользоваться функций ``lineqs``. В случае, если множество решений неограниченно, то алгоритм самостоятельно выберет
границы отрисовки. Однако пользователь сам может указать их явным образом.


Parameters:
""""""""""""""""""

A: float
            Матрица системы линейных алгебраических неравенств.

b: float
            Вектор правой части системы линейных алгебраических неравенств.

show: bool, optional
            Данный параметр отвечает за то будет ли показано множество решений.
            По умолчанию указано значение True, т.е. происходит отрисовка графика.

title: str, optional
            Верхняя легенда графика.

color: str, optional
            Цвет внутренней области множества решений.

bounds: array_like, optional
            Границы отрисовочного окна. Первый элемент массива отвечает за нижние грани по осям OX и OY, а второй за верхние.
            Таким образом, для того, чтобы OX лежало в пределах [-2, 2], а OY в пределах [-3, 4], необходимо задать ``bounds`` как
            [[-2, -3], [2, 4]].

alpha: float, optional
            Прозрачность графика.

s: float, optional
            Насколько велики точки вершин.

size: tuple, optional
            Размер отрисовочного окна.

save: bool, optional
            Если значение True, то график сохраняется.

Returns:
""""""""""""""""""

out: list
            Возвращается список упорядоченных вершин.
            В случае, если show = True, то график отрисовывается.


Examples:
""""""""""""""""""

В качестве примера предлагается рассмотреть систему описывающую двенадцатиугольник:

>>> A = -np.array([[-3, -1],
>>>               [-2, -2],
>>>               [-1, -3],
>>>               [1, -3],
>>>               [2, -2],
>>>               [3, -1],
>>>               [3, 1],
>>>               [2, 2],
>>>               [1, 3],
>>>               [-1, 3],
>>>               [-2, 2],
>>>               [-3, 1]])
>>> b = -np.array([18,16,18,18,16,18,18,16,18,18,16,18])
>>> vertices = ip.lineqs(A, b, title='Duodecagon', color='peru', alpha=0.3, size=(8,8))
array([[-5., -3.], [-6., -0.], [-5.,  3.], [-3.,  5.], [-0.,  6.], [ 3.,  5.],
       [ 5.,  3.], [ 6.,  0.], [ 5., -3.], [ 3., -5.], [ 0., -6.], [-3., -5.]])

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/Duodecagon.png
  :width: 400

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/Duodecagon.png
 :width: 600

```
![Duodecagon](https://github.com/AndrosovAS/intvalpy/blob/master/examples/Duodecagon.png)


Трёхмерная визуализация линейной системы неравенств
~~~~~~~~~~~~~~~~~~

Для работы с линейной системой алгебраических неравенств A x >= b, когда количество неизвестных равно трём, необходимо
воспользоваться функций ``lineqs3D``. В случае, если множество решений неограниченно, то алгоритм самостоятельно выберет
границы отрисовки. Однако пользователь сам может указать их явным образом. Для понимания, что множество решений обрезано,
плоскости окрашиваются в красный цвет.


Parameters:
""""""""""""""""""

A: float
            Матрица системы линейных алгебраических неравенств.

b: float
            Вектор правой части системы линейных алгебраических неравенств.

show: bool, optional
            Данный параметр отвечает за то будет ли показано множество решений.
            По умолчанию указано значение True, т.е. происходит отрисовка графика.

color: str, optional
            Цвет внутренней области множества решений.

bounds: array_like, optional
            Границы отрисовочного окна. Первый элемент массива отвечает за нижние грани по осям OX, OY и OZ, а второй за верхние.
            Таким образом, для того, чтобы OX лежало в пределах [-2, 2], а OY в пределах [-3, 4], а OZ в пределах [1, 5]
            необходимо задать ``bounds`` как [[-2, -3, 1], [2, 4, 5]].

alpha: float, optional
            Прозрачность графика.

s: float, optional
            Насколько велики точки вершин.

size: tuple, optional
            Размер отрисовочного окна.

Returns:
""""""""""""""""""

out: list
            Возвращается список упорядоченных вершин.
            В случае, если show = True, то график отрисовывается.


Examples:
""""""""""""""""""

В качестве примера предлагается рассмотреть систему описывающую юлу:

>>> %matplotlib notebook
>>> k = 4
>>> A = []
>>> for alpha in np.arange(0, 2*np.pi - 0.0001, np.pi/(2*k)):
>>>     for beta in np.arange(-np.pi/2, np.pi/2, np.pi/(2*k)):
>>>         Ai = -np.array([np.sin(alpha), np.cos(alpha), np.sin(beta)])
>>>         Ai /= np.sqrt(Ai @ Ai)
>>>         A.append(Ai)
>>> A = np.array(A)
>>> b = -np.ones(A.shape[0])
>>>
>>> vertices = ip.lineqs3D(A, b)

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/Yula.png
  :width: 400

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/Yula.png
 :width: 600

```
![Yula](https://github.com/AndrosovAS/intvalpy/blob/master/examples/Yula.png)


Визуализация множества решений ИСЛАУ c двумя неизвестными
~~~~~~~~~~~~~~~~~~

Для работы с интервальной линейной системой алгебраических уравнений **A** x = **b**, когда количество неизвестных равно двум,
необходимо воспользоваться функций ``IntLinIncR2``.

Для построения множества решений разобьём основную задачу на четыре подзадачи. Для этого воспользуемся свойством выпуклости решения
в пересечении с каждым из ортантов пространства R\ :sup:`2`, а также характеризацей Бекка. В результате получим
задачи с системами линейных неравенств в каждом ортанте, которые можно визуализировать с помощью функции ``lineqs``.

В случае, если множество решений неограниченно, то алгоритм самостоятельно выберет границы отрисовки. Однако пользователь
сам может указать их явным образом.


Parameters:
""""""""""""""""""

A : Interval
            Входная интервальная матрица ИСЛАУ, которая может быть как квадратной, так и прямоугольной.

b : Interval
            Интервальной вектор правой части ИСЛАУ.

show: bool, optional
            Данный параметр отвечает за то будет ли показано множество решений.
            По умолчанию указано значение True, т.е. происходит отрисовка графика.

title: str, optional
            Верхняя легенда графика.

consistency: str, optional
            Параметр для выбора типа множества решений. В случае, если он равен consistency = 'uni', то функция возвращает
            объединённое множество решение, если consistency = 'tol', то допусковое.

bounds: array_like, optional
            Границы отрисовочного окна. Первый элемент массива отвечает за нижние грани по осям OX и OY, а второй за верхние.
            Таким образом, для того, чтобы OX лежало в пределах [-2, 2], а OY в пределах [-3, 4], необходимо задать ``bounds`` как
            [[-2, -3], [2, 4]].

color: str, optional
            Цвет внутренней области множества решений.

alpha: float, optional
            Прозрачность графика.

s: float, optional
            Насколько велики точки вершин.

size: tuple, optional
            Размер отрисовочного окна.

save: bool, optional
            Если значение True, то график сохраняется.

Returns:
            out: list
                Возвращается список упорядоченных вершин в каждом ортанте
                начиная с первого и совершая обход в положительном направлении.
                В случае, если show = True, то график отрисовывается.


Examples:
""""""""""""""""""

В качестве примера предлагается рассмотреть широкоизвестную интервальную систему предложенную Бартом-Нудингом.
Для наглядности насколько отличаются разные типы решений изобразим на одном графике объединённое и допусковое множества:

>>> import matplotlib.pyplot as plt
>>>
>>> A = ip.Interval([[2, -2],[-1, 2]], [[4,1],[2,4]])
>>> b = ip.Interval([-2, -2], [2, 2])
>>>
>>> fig = plt.figure(figsize=(12,12))
>>> ax = fig.add_subplot(111, title='Barth-Nuding')
>>>
>>> vertices1 = ip.IntLinIncR2(A, b, show=False)
>>> vertices2 = ip.IntLinIncR2(A, b, consistency='tol', show=False)
>>>
>>> for v in vertices1:
>>>     # если пересечение с ортантом не пусто
>>>     if len(v) > 0:
>>>         x, y = v[:,0], v[:,1]
>>>         ax.fill(x, y, linestyle = '-', linewidth = 1, color='gray', alpha=0.5)
>>>         ax.scatter(x, y, s=0, color='black', alpha=1)
>>>
>>> for v in vertices2:
>>>     # если пересечение с ортантом не пусто
>>>     if len(v) > 0:
>>>         x, y = v[:,0], v[:,1]
>>>         ax.fill(x, y, linestyle = '-', linewidth = 1, color='blue', alpha=0.3)
>>>         ax.scatter(x, y, s=10, color='black', alpha=1)

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/Barth-Nuding.png
  :width: 400

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/Barth-Nuding.png
 :width: 600

```
![Barth-Nuding](https://github.com/AndrosovAS/intvalpy/blob/master/examples/Barth-Nuding.png)


Визуализация множества решений ИСЛАУ c тремя неизвестными
~~~~~~~~~~~~~~~~~~

Для работы с интервальной линейной системой алгебраических уравнений **A** x = **b**, когда количество неизвестных равно трём,
необходимо воспользоваться функций ``IntLinIncR3``.

Для построения множества решений разобьём основную задачу на восемь подзадач. Для этого воспользуемся свойством выпуклости решения
в пересечении с каждым из ортантов пространства R\ :sup:`3`, а также характеризацей Бекка. В результате получим
задачи с системами линейных неравенств в каждом ортанте, которые можно визуализировать с помощью функции ``lineqs3D``.

В случае, если множество решений неограниченно, то алгоритм самостоятельно выберет
границы отрисовки. Однако пользователь сам может указать их явным образом. Для понимания, что множество решений обрезано,
плоскости окрашиваются в красный цвет.


Parameters:
""""""""""""""""""

A : Interval
            Входная интервальная матрица ИСЛАУ, которая может быть как квадратной, так и прямоугольной.

b : Interval
            Интервальной вектор правой части ИСЛАУ.

show: bool, optional
            Данный параметр отвечает за то будет ли показано множество решений.
            По умолчанию указано значение True, т.е. происходит отрисовка графика.

consistency: str, optional
            Параметр для выбора типа множества решений. В случае, если он равен consistency = 'uni', то функция возвращает
            объединённое множество решение, если consistency = 'tol', то допусковое.

bounds: array_like, optional
            Границы отрисовочного окна. Первый элемент массива отвечает за нижние грани по осям OX, OY и OZ, а второй за верхние.
            Таким образом, для того, чтобы OX лежало в пределах [-2, 2], а OY в пределах [-3, 4], а OZ в пределах [1, 5]
            необходимо задать ``bounds`` как [[-2, -3, 1], [2, 4, 5]].

color: str, optional
            Цвет внутренней области множества решений.

alpha: float, optional
            Прозрачность графика.

s: float, optional
            Насколько велики точки вершин.

size: tuple, optional
            Размер отрисовочного окна.


Returns:
            out: list
                Возвращается список упорядоченных вершин в каждом ортанте.
                В случае, если show = True, то график отрисовывается.


Examples:
""""""""""""""""""

В качестве примера рассмотрим интервальную систему у которой решением является вся область за исключением внутренности:

>>> %matplotlib notebook
>>> inf = np.array([[-1,-2,-2], [-2,-1,-2], [-2,-2,-1]])
>>> sup = np.array([[1,2,2], [2,1,2], [2,2,1]])
>>> A = ip.Interval(inf, sup)
>>> b = ip.Interval([2,2,2], [2,2,2])
>>>
>>> bounds = [[-5, -5, -5], [5, 5, 5]]
>>> vertices = ip.IntLinIncR3(A, b, alpha=0.5, s=0, bounds=bounds, size=(11,11))

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/figR3.png
  :width: 400

.. image:: https://github.com/AndrosovAS/intvalpy/blob/master/examples/figR3.png
 :width: 600

```
![figR3](https://github.com/AndrosovAS/intvalpy/blob/master/examples/figR3.png)


Список использованной литературы
~~~~~~~~~~~~~~~~~~

[1] И.А. Шарая - `Метод граничных интервалов для визуализации полиэдральных множеств решений <http://www.nsc.ru/interval/sharaya/Papers/Sharaya-JCT2015.pdf>`_ // Вычислительные технологии, Том 20, No 1, 2015, стр. 75-103.

[2] П.А. Щербина - `Метод граничных интервалов в свободной системе компьютерной математики Scilab <http://www.nsc.ru/interval/Education/StudWorks/Shcherbina-diplom.pdf>`_

[3] С.П. Шарый - `монография <http://www.nsc.ru/interval/Library/InteBooks/SharyBook.pdf>`_.


Метод Гаусса
------------

Метод Гаусса для решения ИСЛАУ можно вызвать с помощью функции ``Gauss``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Returns:
            out: Interval
                Возвращается интервальный вектор решений.

Пример:

>>> import intvalpy as ip
>>>
>>> A = ip.Interval([[2, -2],[-1, 2]], [[4, 1],[2, 4]])
>>> b = ip.Interval([-2, -2], [2, 2])
>>>
>>> ip.linear.Gauss(A, b)
interval(['[-5.0, 5.0]', '[-4.0, 4.0]'])


Метод Гаусса-Зейделя
------------

Итерационный метод Гаусса-Зейделя для решения ИСЛАУ можно вызвать с помощью функции ``Gauss_Seidel``:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            x0: Interval
                Начальный брус, в котором ищется решение.

            P: Interval
                Матрица предобуславливания.
                В случае, если параметр не задан, то берётся обратное среднее.

            tol: float
                Погрешность для остановки итерационного процесса.

            maxiter: int
                Максимальное количество итераций.

Returns:
            out: Interval
                Возвращается интервальный вектор решений.

Пример:

>>> import intvalpy as ip
>>>
>>> A = ip.Interval([[0.5, -0.456], [-0.438, 0.624]],
>>>                  [[1.176, 0.448], [0.596, 1.36]])
>>> b = ip.Interval([0.316, 0.27], [0.632, 0.624])
>>>
>>> ip.linear.Gauss_Seidel(A, b, P=False)
interval(['[-4.266757, 6.076814]', '[-5.371444, 5.265456]'])


Метод Рона для переопределённых систем
------------

Метод Дж. Рона для переопределённых ИСЛАУ:

Parameters:
            A: Interval
                Матрица ИСЛАУ.

            b: Interval
                Вектор правой части ИСЛАУ.

Optional Parameters:
            tol: float
                Погрешность для остановки итерационного процесса.

            maxiter: int
                Максимальное количество итераций.

Returns:
            out: Interval
                Возвращается интервальный вектор решений.

Пример:

>>> import numpy as np
>>> import intvalpy as ip
>>>
>>> t = np.array([31, 69, 144, 198, 359, 446, 536, 626, 716, 809, 903, 1039, 1161, \
>>>               1316, 1536, 2029, 2400, 29, 64, 135, 189, 261, 342, 432, 517, 613, \
>>>               699, 792, 888, 1020, 1142, 1301, 1511, 2017, 2400, 65, 96, 521, 617, \
>>>               705, 794, 892, 1024, 1148, 1309, 1520, 2003, 2400, 27, 83, 121, 173, \
>>>               234, 307, 394, 467, 553, 636, 715, 806, 915, 1026, 1170, 1364, 1500, \
>>>               2400, 77, 112, 155, 216, 367, 458, 541, 639, 741, 825, 936, 1061, \
>>>               1189, 1200, 1426, 1902, 2400, 67, 102, 145, 206, 357, 448, 531, 629, \
>>>               731, 815, 900, 1030, 1115, 1326, 1554, 2015, 2400]);
>>> data = np.array([0.8, 0.84, 0.85, 0.89, 0.93, 0.93, 0.93, 0.93, 0.93, 0.93, 0.93, \
>>>                  0.95, 0.95, 0.96, 0.97, 0.99, 1, 0.79, 0.82, 0.85, 0.89, 0.91, 0.92, \
>>>                  0.93, 0.93, 0.94, 0.93, 0.93, 0.94, 0.95, 0.95, 0.96, 0.97, 0.99, 1, \
>>>                  0.84, 0.84, 0.94, 0.94, 0.94, 0.95, 0.95, 0.96, 0.96, 0.97, 0.96, \
>>>                  0.97, 1, 0.78, 0.81, 0.84, 0.89, 0.9, 0.92, 0.93, 0.92, 0.93, 0.93, \
>>>                  0.92, 0.93, 0.95, 0.95, 0.96, 0.97, 0.98, 1, 0.8, 0.82, 0.86, 0.9, \
>>>                  0.91, 0.93, 0.93, 0.94, 0.94, 0.93, 0.94, 0.95, 0.95, 0.96, 0.96, \
>>>                  0.98, 1, 0.81, 0.83, 0.86, 0.9, 0.91, 0.93, 0.93, 0.94, 0.94, 0.93, \
>>>                  0.93, 0.94, 0.94, 0.97, 0.96, 0.98, 1])
>>>
>>> t = t + ip.Interval(0, 0)
>>> data = data + ip.Interval(-0.0255, 0.0255)
>>>
>>> A = ip.zeros((100, 2))
>>> A[:, 0] += ip.Interval(1, 1)
>>> A[:, 1] -= data
>>> b = t * (data - 1)
>>>
>>> ip.linear.Rohn(A, b)
interval(['[-396.621157, 575.293503]', '[-418.434473, 687.961243]'])


Более подробную информацию Вы можете узнать из `статьи <https://www.researchgate.net/publication/220252801_Enclosing_solutions_of_overdetermined_systems_of_linear_interval_equations>`_ Дж. Рона.


Метод дробления решений
------------

Гибридный метод дробления решений PSS, подробно описанный в `монографии <http://www.nsc.ru/interval/Library/InteBooks/SharyBook.pdf>`_. PSS-алгортимы предназначены для нахождения внешних оптимальных оценок множеств решений интервальных систем линейных алгебраических уравнений (ИСЛАУ) **A** x = **b**.

В качестве базового метода внешнего оценивания в программе используется интервальный метод Гаусса (функция Gauss), если система является квадратной. В случае, если система переопределённая, то применяется простейший алгоритм, предложенный Дж. Роном (функция Rohn). Поскольку задача NP-трудная, то остановка процесса может произойти по количеству пройденных итераций. PSS-методы являются последовательно гарантирующими, т.е. при обрыве процесса на любом количестве итераций приближённая оценка решения удовлетворяет требуемому способу оценивания.

Возвращает формальное решение интервальной системы линейных уравнений. В случае, если оценивать все компоненты нет необходимости, то можно оценить одну любую nu-ю компоненту.


Parameters
~~~~~~~~~~~~~~~~~~
A : Interval
            Входная интервальная матрица ИСЛАУ, которая может быть как квадратной, так и прямоугольной.

b : Interval
            Интервальной вектор правой части ИСЛАУ.

tol : float, optional
            Погрешность, определающая, когда дальнейшее дробление брусов излишне, т.е. их ширина "достаточно близка" к нулю, что может считаться точно нулевой.

maxiter : int, optional
            Максимальное количество итераций для выполнения алгоритма.

nu : int, optional
            Выбор номера компоненты, вдоль которой оценивается множество решений.


Returns
~~~~~~~~~~~~~~~~~~
out : Interval
    Интервальный вектор, который после подстановки в систему уравнений и выполнения всех операций по правилам арифметики и анализа обращает уравнения в инстинные равенства.


Examples
~~~~~~~~~~~~~~~~~~
>>> A, b = ip.Shary(4)
>>> ip.linear.PSS(A, b)
interval(['[-4.347826, 4.347826]', '[-4.347826, 4.347826]', '[-4.347826, 4.347826]', '[-4.347826, 4.347826]'])

Возврат интервального вектора решения NP-трудной системы.

>>> A, b = ip.Neumeier(3, 3.33)
>>> ip.linear.PSS(A, b, nu=0, maxiter=5000)
interval(['[-2.373013, 2.373013]'])

Возвращена отдельная компонента. В связи с тем, что в системе Ноймаера параметр theta=3.33 является жёстким условием, необходимо увеличить количество итераций для получения оптимальной оценки.
